// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpckeystore.proto

/*
Package grpckeystore is a generated protocol buffer package.

It is generated from these files:
	grpckeystore.proto

It has these top-level messages:
	GenerateKeyReq
	GenerateKeyRsp
	AssociateKeyReq
	AssociateKeyRsp
	AddKeyReq
	AddKeyRsp
	GetKeyReq
	GetKeyRsp
	ListKeysReq
	ListKeysRsp
	RemoveKeyReq
	RemoveKeyRsp
	SignReq
	SignRsp
*/
package grpckeystore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GenerateKeyReq struct {
	Gun  string `protobuf:"bytes,1,opt,name=Gun" json:"Gun,omitempty"`
	Role string `protobuf:"bytes,2,opt,name=Role" json:"Role,omitempty"`
}

func (m *GenerateKeyReq) Reset()                    { *m = GenerateKeyReq{} }
func (m *GenerateKeyReq) String() string            { return proto.CompactTextString(m) }
func (*GenerateKeyReq) ProtoMessage()               {}
func (*GenerateKeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GenerateKeyReq) GetGun() string {
	if m != nil {
		return m.Gun
	}
	return ""
}

func (m *GenerateKeyReq) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

type GenerateKeyRsp struct {
	RemoteKeyId        string `protobuf:"bytes,1,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
	PublicKey          []byte `protobuf:"bytes,2,opt,name=PublicKey,proto3" json:"PublicKey,omitempty"`
	Algorithm          string `protobuf:"bytes,3,opt,name=Algorithm" json:"Algorithm,omitempty"`
	SignatureAlgorithm string `protobuf:"bytes,4,opt,name=SignatureAlgorithm" json:"SignatureAlgorithm,omitempty"`
}

func (m *GenerateKeyRsp) Reset()                    { *m = GenerateKeyRsp{} }
func (m *GenerateKeyRsp) String() string            { return proto.CompactTextString(m) }
func (*GenerateKeyRsp) ProtoMessage()               {}
func (*GenerateKeyRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GenerateKeyRsp) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

func (m *GenerateKeyRsp) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *GenerateKeyRsp) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *GenerateKeyRsp) GetSignatureAlgorithm() string {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return ""
}

type AssociateKeyReq struct {
	RemoteKeyId string `protobuf:"bytes,1,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
	KeyId       string `protobuf:"bytes,2,opt,name=KeyId" json:"KeyId,omitempty"`
}

func (m *AssociateKeyReq) Reset()                    { *m = AssociateKeyReq{} }
func (m *AssociateKeyReq) String() string            { return proto.CompactTextString(m) }
func (*AssociateKeyReq) ProtoMessage()               {}
func (*AssociateKeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AssociateKeyReq) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

func (m *AssociateKeyReq) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

type AssociateKeyRsp struct {
}

func (m *AssociateKeyRsp) Reset()                    { *m = AssociateKeyRsp{} }
func (m *AssociateKeyRsp) String() string            { return proto.CompactTextString(m) }
func (*AssociateKeyRsp) ProtoMessage()               {}
func (*AssociateKeyRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type AddKeyReq struct {
	KeyId              string `protobuf:"bytes,1,opt,name=KeyId" json:"KeyId,omitempty"`
	Gun                string `protobuf:"bytes,2,opt,name=Gun" json:"Gun,omitempty"`
	Role               string `protobuf:"bytes,3,opt,name=Role" json:"Role,omitempty"`
	Algorithm          string `protobuf:"bytes,4,opt,name=Algorithm" json:"Algorithm,omitempty"`
	SignatureAlgorithm string `protobuf:"bytes,5,opt,name=SignatureAlgorithm" json:"SignatureAlgorithm,omitempty"`
	PublicKey          []byte `protobuf:"bytes,6,opt,name=PublicKey,proto3" json:"PublicKey,omitempty"`
	PrivateKey         []byte `protobuf:"bytes,7,opt,name=PrivateKey,proto3" json:"PrivateKey,omitempty"`
}

func (m *AddKeyReq) Reset()                    { *m = AddKeyReq{} }
func (m *AddKeyReq) String() string            { return proto.CompactTextString(m) }
func (*AddKeyReq) ProtoMessage()               {}
func (*AddKeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AddKeyReq) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *AddKeyReq) GetGun() string {
	if m != nil {
		return m.Gun
	}
	return ""
}

func (m *AddKeyReq) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *AddKeyReq) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *AddKeyReq) GetSignatureAlgorithm() string {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return ""
}

func (m *AddKeyReq) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *AddKeyReq) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

type AddKeyRsp struct {
	RemoteKeyId string `protobuf:"bytes,1,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
}

func (m *AddKeyRsp) Reset()                    { *m = AddKeyRsp{} }
func (m *AddKeyRsp) String() string            { return proto.CompactTextString(m) }
func (*AddKeyRsp) ProtoMessage()               {}
func (*AddKeyRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AddKeyRsp) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

type GetKeyReq struct {
	KeyId       string `protobuf:"bytes,1,opt,name=KeyId" json:"KeyId,omitempty"`
	RemoteKeyId string `protobuf:"bytes,2,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
}

func (m *GetKeyReq) Reset()                    { *m = GetKeyReq{} }
func (m *GetKeyReq) String() string            { return proto.CompactTextString(m) }
func (*GetKeyReq) ProtoMessage()               {}
func (*GetKeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetKeyReq) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *GetKeyReq) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

type GetKeyRsp struct {
	Role               string `protobuf:"bytes,1,opt,name=Role" json:"Role,omitempty"`
	Algorithm          string `protobuf:"bytes,2,opt,name=Algorithm" json:"Algorithm,omitempty"`
	SignatureAlgorithm string `protobuf:"bytes,3,opt,name=SignatureAlgorithm" json:"SignatureAlgorithm,omitempty"`
	PublicKey          []byte `protobuf:"bytes,4,opt,name=PublicKey,proto3" json:"PublicKey,omitempty"`
}

func (m *GetKeyRsp) Reset()                    { *m = GetKeyRsp{} }
func (m *GetKeyRsp) String() string            { return proto.CompactTextString(m) }
func (*GetKeyRsp) ProtoMessage()               {}
func (*GetKeyRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetKeyRsp) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *GetKeyRsp) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *GetKeyRsp) GetSignatureAlgorithm() string {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return ""
}

func (m *GetKeyRsp) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type ListKeysReq struct {
}

func (m *ListKeysReq) Reset()                    { *m = ListKeysReq{} }
func (m *ListKeysReq) String() string            { return proto.CompactTextString(m) }
func (*ListKeysReq) ProtoMessage()               {}
func (*ListKeysReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type ListKeysRsp struct {
	KeyData []*ListKeysRsp_KeyInfo `protobuf:"bytes,1,rep,name=KeyData" json:"KeyData,omitempty"`
}

func (m *ListKeysRsp) Reset()                    { *m = ListKeysRsp{} }
func (m *ListKeysRsp) String() string            { return proto.CompactTextString(m) }
func (*ListKeysRsp) ProtoMessage()               {}
func (*ListKeysRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListKeysRsp) GetKeyData() []*ListKeysRsp_KeyInfo {
	if m != nil {
		return m.KeyData
	}
	return nil
}

type ListKeysRsp_KeyInfo struct {
	KeyId       string `protobuf:"bytes,1,opt,name=KeyId" json:"KeyId,omitempty"`
	RemoteKeyId string `protobuf:"bytes,2,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
	Gun         string `protobuf:"bytes,3,opt,name=Gun" json:"Gun,omitempty"`
	Role        string `protobuf:"bytes,4,opt,name=Role" json:"Role,omitempty"`
}

func (m *ListKeysRsp_KeyInfo) Reset()                    { *m = ListKeysRsp_KeyInfo{} }
func (m *ListKeysRsp_KeyInfo) String() string            { return proto.CompactTextString(m) }
func (*ListKeysRsp_KeyInfo) ProtoMessage()               {}
func (*ListKeysRsp_KeyInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

func (m *ListKeysRsp_KeyInfo) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *ListKeysRsp_KeyInfo) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

func (m *ListKeysRsp_KeyInfo) GetGun() string {
	if m != nil {
		return m.Gun
	}
	return ""
}

func (m *ListKeysRsp_KeyInfo) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

type RemoveKeyReq struct {
	KeyId       string `protobuf:"bytes,1,opt,name=KeyId" json:"KeyId,omitempty"`
	RemoteKeyId string `protobuf:"bytes,2,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
}

func (m *RemoveKeyReq) Reset()                    { *m = RemoveKeyReq{} }
func (m *RemoveKeyReq) String() string            { return proto.CompactTextString(m) }
func (*RemoveKeyReq) ProtoMessage()               {}
func (*RemoveKeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RemoveKeyReq) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *RemoveKeyReq) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

type RemoveKeyRsp struct {
}

func (m *RemoveKeyRsp) Reset()                    { *m = RemoveKeyRsp{} }
func (m *RemoveKeyRsp) String() string            { return proto.CompactTextString(m) }
func (*RemoveKeyRsp) ProtoMessage()               {}
func (*RemoveKeyRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type SignReq struct {
	KeyId         string `protobuf:"bytes,1,opt,name=KeyId" json:"KeyId,omitempty"`
	RemoteKeyId   string `protobuf:"bytes,2,opt,name=RemoteKeyId" json:"RemoteKeyId,omitempty"`
	HashAlgorithm string `protobuf:"bytes,3,opt,name=HashAlgorithm" json:"HashAlgorithm,omitempty"`
	Message       []byte `protobuf:"bytes,4,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *SignReq) Reset()                    { *m = SignReq{} }
func (m *SignReq) String() string            { return proto.CompactTextString(m) }
func (*SignReq) ProtoMessage()               {}
func (*SignReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SignReq) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *SignReq) GetRemoteKeyId() string {
	if m != nil {
		return m.RemoteKeyId
	}
	return ""
}

func (m *SignReq) GetHashAlgorithm() string {
	if m != nil {
		return m.HashAlgorithm
	}
	return ""
}

func (m *SignReq) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

type SignRsp struct {
	Signature []byte `protobuf:"bytes,1,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *SignRsp) Reset()                    { *m = SignRsp{} }
func (m *SignRsp) String() string            { return proto.CompactTextString(m) }
func (*SignRsp) ProtoMessage()               {}
func (*SignRsp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SignRsp) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterType((*GenerateKeyReq)(nil), "grpckeystore.GenerateKeyReq")
	proto.RegisterType((*GenerateKeyRsp)(nil), "grpckeystore.GenerateKeyRsp")
	proto.RegisterType((*AssociateKeyReq)(nil), "grpckeystore.AssociateKeyReq")
	proto.RegisterType((*AssociateKeyRsp)(nil), "grpckeystore.AssociateKeyRsp")
	proto.RegisterType((*AddKeyReq)(nil), "grpckeystore.AddKeyReq")
	proto.RegisterType((*AddKeyRsp)(nil), "grpckeystore.AddKeyRsp")
	proto.RegisterType((*GetKeyReq)(nil), "grpckeystore.GetKeyReq")
	proto.RegisterType((*GetKeyRsp)(nil), "grpckeystore.GetKeyRsp")
	proto.RegisterType((*ListKeysReq)(nil), "grpckeystore.ListKeysReq")
	proto.RegisterType((*ListKeysRsp)(nil), "grpckeystore.ListKeysRsp")
	proto.RegisterType((*ListKeysRsp_KeyInfo)(nil), "grpckeystore.ListKeysRsp.KeyInfo")
	proto.RegisterType((*RemoveKeyReq)(nil), "grpckeystore.RemoveKeyReq")
	proto.RegisterType((*RemoveKeyRsp)(nil), "grpckeystore.RemoveKeyRsp")
	proto.RegisterType((*SignReq)(nil), "grpckeystore.SignReq")
	proto.RegisterType((*SignRsp)(nil), "grpckeystore.SignRsp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GRPCKeyStore service

type GRPCKeyStoreClient interface {
	// GenerateKey allows the key store to provide a key it has
	// originated.  This allows a key store to provide signing services
	// and never divulge private key information. Its permissible to use
	// the same key for different GUNs, if desired.
	// (GenerateKey/AssociateKey is an alternative to AddKey)
	GenerateKey(ctx context.Context, in *GenerateKeyReq, opts ...grpc.CallOption) (*GenerateKeyRsp, error)
	// AssociateKey always follows a successful GenerateKey.  It allows notary to
	// inform the key store the KeyId that is associated with this key
	AssociateKey(ctx context.Context, in *AssociateKeyReq, opts ...grpc.CallOption) (*AssociateKeyRsp, error)
	// AddKey allows a key generated by Notary to be saved in the key store.
	// AddKey is an alternative to the GenerateKey/AssociateKey sequence.
	// All AddKey keys are implicitly associated.
	AddKey(ctx context.Context, in *AddKeyReq, opts ...grpc.CallOption) (*AddKeyRsp, error)
	// GetKey retrieves a stored public key from the key store
	GetKey(ctx context.Context, in *GetKeyReq, opts ...grpc.CallOption) (*GetKeyRsp, error)
	// ListKeys retrieves association data about all keys available in the
	// key store.  It does not return the public key.
	ListKeys(ctx context.Context, in *ListKeysReq, opts ...grpc.CallOption) (*ListKeysRsp, error)
	// RemoveKey removes a key association from the key store.  If all
	// associations are removed for a key, it can be removed from the store.
	RemoveKey(ctx context.Context, in *RemoveKeyReq, opts ...grpc.CallOption) (*RemoveKeyRsp, error)
	// Sign a message with the specified key
	Sign(ctx context.Context, in *SignReq, opts ...grpc.CallOption) (*SignRsp, error)
}

type gRPCKeyStoreClient struct {
	cc *grpc.ClientConn
}

func NewGRPCKeyStoreClient(cc *grpc.ClientConn) GRPCKeyStoreClient {
	return &gRPCKeyStoreClient{cc}
}

func (c *gRPCKeyStoreClient) GenerateKey(ctx context.Context, in *GenerateKeyReq, opts ...grpc.CallOption) (*GenerateKeyRsp, error) {
	out := new(GenerateKeyRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/GenerateKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCKeyStoreClient) AssociateKey(ctx context.Context, in *AssociateKeyReq, opts ...grpc.CallOption) (*AssociateKeyRsp, error) {
	out := new(AssociateKeyRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/AssociateKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCKeyStoreClient) AddKey(ctx context.Context, in *AddKeyReq, opts ...grpc.CallOption) (*AddKeyRsp, error) {
	out := new(AddKeyRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/AddKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCKeyStoreClient) GetKey(ctx context.Context, in *GetKeyReq, opts ...grpc.CallOption) (*GetKeyRsp, error) {
	out := new(GetKeyRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/GetKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCKeyStoreClient) ListKeys(ctx context.Context, in *ListKeysReq, opts ...grpc.CallOption) (*ListKeysRsp, error) {
	out := new(ListKeysRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/ListKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCKeyStoreClient) RemoveKey(ctx context.Context, in *RemoveKeyReq, opts ...grpc.CallOption) (*RemoveKeyRsp, error) {
	out := new(RemoveKeyRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/RemoveKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCKeyStoreClient) Sign(ctx context.Context, in *SignReq, opts ...grpc.CallOption) (*SignRsp, error) {
	out := new(SignRsp)
	err := grpc.Invoke(ctx, "/grpckeystore.GRPCKeyStore/Sign", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GRPCKeyStore service

type GRPCKeyStoreServer interface {
	// GenerateKey allows the key store to provide a key it has
	// originated.  This allows a key store to provide signing services
	// and never divulge private key information. Its permissible to use
	// the same key for different GUNs, if desired.
	// (GenerateKey/AssociateKey is an alternative to AddKey)
	GenerateKey(context.Context, *GenerateKeyReq) (*GenerateKeyRsp, error)
	// AssociateKey always follows a successful GenerateKey.  It allows notary to
	// inform the key store the KeyId that is associated with this key
	AssociateKey(context.Context, *AssociateKeyReq) (*AssociateKeyRsp, error)
	// AddKey allows a key generated by Notary to be saved in the key store.
	// AddKey is an alternative to the GenerateKey/AssociateKey sequence.
	// All AddKey keys are implicitly associated.
	AddKey(context.Context, *AddKeyReq) (*AddKeyRsp, error)
	// GetKey retrieves a stored public key from the key store
	GetKey(context.Context, *GetKeyReq) (*GetKeyRsp, error)
	// ListKeys retrieves association data about all keys available in the
	// key store.  It does not return the public key.
	ListKeys(context.Context, *ListKeysReq) (*ListKeysRsp, error)
	// RemoveKey removes a key association from the key store.  If all
	// associations are removed for a key, it can be removed from the store.
	RemoveKey(context.Context, *RemoveKeyReq) (*RemoveKeyRsp, error)
	// Sign a message with the specified key
	Sign(context.Context, *SignReq) (*SignRsp, error)
}

func RegisterGRPCKeyStoreServer(s *grpc.Server, srv GRPCKeyStoreServer) {
	s.RegisterService(&_GRPCKeyStore_serviceDesc, srv)
}

func _GRPCKeyStore_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/GenerateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).GenerateKey(ctx, req.(*GenerateKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCKeyStore_AssociateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssociateKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).AssociateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/AssociateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).AssociateKey(ctx, req.(*AssociateKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCKeyStore_AddKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).AddKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/AddKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).AddKey(ctx, req.(*AddKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCKeyStore_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/GetKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).GetKey(ctx, req.(*GetKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCKeyStore_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/ListKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).ListKeys(ctx, req.(*ListKeysReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCKeyStore_RemoveKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).RemoveKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/RemoveKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).RemoveKey(ctx, req.(*RemoveKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCKeyStore_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCKeyStoreServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpckeystore.GRPCKeyStore/Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCKeyStoreServer).Sign(ctx, req.(*SignReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _GRPCKeyStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpckeystore.GRPCKeyStore",
	HandlerType: (*GRPCKeyStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateKey",
			Handler:    _GRPCKeyStore_GenerateKey_Handler,
		},
		{
			MethodName: "AssociateKey",
			Handler:    _GRPCKeyStore_AssociateKey_Handler,
		},
		{
			MethodName: "AddKey",
			Handler:    _GRPCKeyStore_AddKey_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _GRPCKeyStore_GetKey_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _GRPCKeyStore_ListKeys_Handler,
		},
		{
			MethodName: "RemoveKey",
			Handler:    _GRPCKeyStore_RemoveKey_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _GRPCKeyStore_Sign_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpckeystore.proto",
}

func init() { proto.RegisterFile("grpckeystore.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 561 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xee, 0xc6, 0x6e, 0xf2, 0xcb, 0xc4, 0xed, 0x0f, 0x46, 0x20, 0x5c, 0xab, 0xa0, 0xb0, 0x42,
	0xa2, 0x17, 0x72, 0x28, 0x52, 0x2f, 0x70, 0x09, 0x05, 0x42, 0x15, 0x40, 0x91, 0xfb, 0x04, 0x6e,
	0xb2, 0xb8, 0x16, 0x69, 0xec, 0x78, 0x9d, 0x4a, 0x3e, 0x72, 0xe6, 0x1d, 0x78, 0x09, 0x1e, 0x85,
	0xb7, 0xe0, 0x29, 0xd0, 0xae, 0xff, 0xed, 0x3a, 0x71, 0x88, 0xe8, 0xcd, 0xfb, 0xcd, 0x7c, 0x9f,
	0x76, 0xbe, 0x99, 0x1d, 0x03, 0xfa, 0x71, 0x34, 0xfd, 0xca, 0x52, 0x9e, 0x84, 0x31, 0x1b, 0x44,
	0x71, 0x98, 0x84, 0x68, 0xa9, 0x18, 0x3d, 0x83, 0xc3, 0x11, 0x5b, 0xb0, 0xd8, 0x4b, 0xd8, 0x98,
	0xa5, 0x2e, 0x5b, 0xe2, 0x3d, 0x30, 0x46, 0xab, 0x85, 0x4d, 0xfa, 0xe4, 0xa4, 0xeb, 0x8a, 0x4f,
	0x44, 0x30, 0xdd, 0x70, 0xce, 0xec, 0x96, 0x84, 0xe4, 0x37, 0xfd, 0x41, 0x74, 0x22, 0x8f, 0xb0,
	0x0f, 0x3d, 0x97, 0xdd, 0x84, 0xf2, 0x7c, 0x31, 0xcb, 0x05, 0x54, 0x08, 0x8f, 0xa1, 0x3b, 0x59,
	0x5d, 0xcd, 0x83, 0xe9, 0x98, 0xa5, 0x52, 0xcd, 0x72, 0x2b, 0x40, 0x44, 0x87, 0x73, 0x3f, 0x8c,
	0x83, 0xe4, 0xfa, 0xc6, 0x36, 0x24, 0xbb, 0x02, 0x70, 0x00, 0x78, 0x19, 0xf8, 0x0b, 0x2f, 0x59,
	0xc5, 0xac, 0x4a, 0x33, 0x65, 0xda, 0x86, 0x08, 0xbd, 0x80, 0xff, 0x87, 0x9c, 0x87, 0xd3, 0xa0,
	0xaa, 0xec, 0xef, 0x17, 0x7c, 0x00, 0xfb, 0x59, 0x2c, 0x2b, 0x35, 0x3b, 0xd0, 0xfb, 0x35, 0x29,
	0x1e, 0xd1, 0x5f, 0x04, 0xba, 0xc3, 0xd9, 0x2c, 0x17, 0x2e, 0x69, 0x44, 0xa1, 0x15, 0x46, 0xb6,
	0xd6, 0x8d, 0x34, 0x2a, 0x23, 0xf5, 0xaa, 0xcd, 0xdd, 0xaa, 0xde, 0x6f, 0xaa, 0x5a, 0x77, 0xb8,
	0x5d, 0x77, 0xf8, 0x09, 0xc0, 0x24, 0x0e, 0x6e, 0xb3, 0x32, 0xec, 0x8e, 0x0c, 0x2b, 0x08, 0x7d,
	0x51, 0x16, 0xb5, 0x4b, 0x3b, 0xe9, 0x39, 0x74, 0x47, 0x2c, 0xd9, 0xea, 0x41, 0x4d, 0xa4, 0xb5,
	0x2e, 0xf2, 0x9d, 0x94, 0x2a, 0x3c, 0x2a, 0x1d, 0x22, 0x4d, 0x0e, 0xb5, 0x76, 0x73, 0xc8, 0xd8,
	0xcd, 0x21, 0xb3, 0xe6, 0x10, 0x3d, 0x80, 0xde, 0xc7, 0x80, 0x8b, 0xdb, 0x70, 0x97, 0x2d, 0xe9,
	0x4f, 0xa2, 0x9c, 0x79, 0x84, 0xaf, 0xa0, 0x33, 0x66, 0xe9, 0x5b, 0x2f, 0xf1, 0x6c, 0xd2, 0x37,
	0x4e, 0x7a, 0xa7, 0x4f, 0x07, 0xda, 0x0b, 0x53, 0x72, 0x07, 0xa2, 0xbc, 0xc5, 0x97, 0xd0, 0x2d,
	0x18, 0x8e, 0x2f, 0xc9, 0x02, 0xfb, 0x57, 0xb3, 0x8a, 0x91, 0x32, 0xd6, 0x47, 0xca, 0x54, 0xde,
	0xe6, 0x7b, 0xb0, 0x04, 0xe9, 0x96, 0xdd, 0xb1, 0x35, 0x87, 0xaa, 0x0e, 0x8f, 0xe8, 0x37, 0x02,
	0x1d, 0xe1, 0xe8, 0x1d, 0x34, 0xf1, 0x19, 0x1c, 0x7c, 0xf0, 0xf8, 0x75, 0xbd, 0x53, 0x3a, 0x88,
	0x36, 0x74, 0x3e, 0x31, 0xce, 0x3d, 0x9f, 0xe5, 0x2d, 0x2a, 0x8e, 0xf4, 0x79, 0x7e, 0x05, 0x1e,
	0x89, 0x4e, 0x96, 0xfd, 0x95, 0xd7, 0xb0, 0xdc, 0x0a, 0x38, 0xfd, 0x6d, 0x80, 0x35, 0x72, 0x27,
	0xe7, 0x63, 0x96, 0x5e, 0x8a, 0xde, 0xe0, 0x18, 0x7a, 0xca, 0xc2, 0xc2, 0x63, 0xbd, 0x73, 0xfa,
	0x12, 0x74, 0xb6, 0x44, 0x79, 0x44, 0xf7, 0xf0, 0x33, 0x58, 0xea, 0x4a, 0xc0, 0xc7, 0x7a, 0x7e,
	0x6d, 0xf3, 0x38, 0xdb, 0xc2, 0x52, 0xef, 0x35, 0xb4, 0xb3, 0x97, 0x87, 0x8f, 0x6a, 0xa9, 0xc5,
	0x92, 0x71, 0x36, 0x07, 0x0a, 0x76, 0xf6, 0x84, 0xea, 0xec, 0xf2, 0x79, 0x3a, 0x9b, 0x03, 0x92,
	0xfd, 0x06, 0xfe, 0x2b, 0xe6, 0x16, 0x8f, 0x1a, 0xe6, 0x99, 0x2d, 0x9d, 0xa3, 0xc6, 0x51, 0xa7,
	0x7b, 0xf8, 0x0e, 0xba, 0xe5, 0xa8, 0xa0, 0xa3, 0x67, 0xaa, 0xb3, 0xe8, 0x34, 0xc6, 0xa4, 0xcc,
	0x19, 0x98, 0xa2, 0x83, 0xf8, 0x50, 0xcf, 0xca, 0x87, 0xce, 0xd9, 0x04, 0x0b, 0xde, 0x55, 0x5b,
	0xfe, 0xda, 0x5e, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x09, 0x25, 0x77, 0xec, 0xf0, 0x06, 0x00,
	0x00,
}
